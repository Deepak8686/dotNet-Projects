Action filters:
```````````````
are used to modify the behavior of actions before or after methods are executed, or to provide additional processing during the execution of the action.

Exception filters: 
`````````````````
in ASP.NET are a feature that allows you to handle exceptions that occur during the execution of code such as a controller action or a method call code in a centralized way.


Lifecycle of data annotations:
````````````````````````````
 Data annotations are used to specify metadata for data models in an application.
 
They can be used to provide validation rules, display names, and other information about the data that is being used in the application. 

The lifecycle of data annotations depends on the framework or library being used in the application. 

In general, data annotations are read and applied by the framework or library during runtime. 

For example, in ASP.NET MVC, data annotations are used to validate user input on the server side, 
and the validation occurs during the Model Binding phase of the request lifecycle.

In a .NET Web API application, data annotations can be applied to model properties to enforce certain constraints or validation rules on the data being received by the API. When a request is received by the API, the model binder inspects the model properties and checks for any data annotations applied to them


Request lifecycle:
`````````````````` 

The request lifecycle refers to the series of events that occur when a client sends a request to a server and the server processes that request. 
The exact details of the request lifecycle depend on the specific web framework or library being used. 

In general, the request lifecycle includes the following steps:

1. Routing: The server determines which controller and action method should handle the request based on the URL and any route definitions.

2. Model Binding: The server extracts data from the request (such as form data or query string parameters) and maps it to the relevant data models or view models.

3. Validation: The server checks the validity of the data based on any validation rules defined, such as data annotations.

4. Execution: The server runs the appropriate controller action method and generates a response to send back to the client.

5. Rendering: The server renders the response content (such as HTML or JSON) and sends it back to the client.





 Example values generated for properties that do not have a specific example value provided:---> Couldn't identify Solution. 

The password value in your Swagger documentation is likely being generated by the Swagger UI, which can generate example values for any properties that do not have a specific example value provided.

In your case, since you have not provided a specific example value for the Password property, the Swagger UI is generating a random example value that matches the regular expression you specified in the RegularExpression attribute.

If you want to prevent the Swagger UI from generating example values for the Password property, you can provide a specific example value using the Example attribute, like this:


[RegularExpression(@"^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[^\da-zA-Z]).{8,}$",
   ErrorMessage = "Invalid password pattern (Eg, Abcd!@#$%^&*1234)")]
[Example("Abcd!@#$%^&*1234")]

public string Password { get; set; }


This will cause the Swagger UI to use the provided example value instead of generating a random one.----> example annotation is overrided



services.AddSwaggerGen(c =>
{
    // Disable example generation
    c.EnableAnnotations(false);
});  ---> not working..


throws---> SwaggerGenOptions' does not contain a definition for 'EnableAnnotations' and no accessible extension method 'EnableAnnotations' accepting a first argument of type 'SwaggerGenOptions' could be found (are you missing a using directive or an assembly reference?)	
